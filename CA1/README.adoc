# Technical Report for CA1

## Introduction

This technical report documents the development process, decisions, and implementation details of the CA1 assignment. The assignment involves enhancing a React.js and Spring Data REST application by introducing new features and applying version control best practices with Git.

## Git Repository Initialization and Setup

```bash
echo "# repository-name" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin git@github.com:username/repository-name.git
git push -u origin main
```

## Requirements Analysis and Design

### Overview

The assignment entails several key tasks:

1. Copying the code of the Tutorial React.js and Spring Data REST Application into a new folder named CA1.
2. Committing the changes and pushing them to the repository.
3. Tagging the initial version as v1.1.0 and pushing the tag to the server.
4. Developing a new feature to add a "jobYears" field to the Employee entity.
5. Creating unit tests for the new field and ensuring validation for integer values only.
6. Debugging the server and client parts of the solution.
7. Committing the new feature, pushing the changes, and tagging the repository as v1.2.0.
8. Using the master branch to "publish" the "stable" versions of the Tutorial React.js and Spring Data REST Application.
9. Developing new features in branches named after the feature. For example, creating a branch named "email-field" to add a new email field to the application.
10. Creating a branch called fix-invalid-email. The server should only accept Employees with a valid email (e.g., an email must have the "@" sign).
11. Merging into the master branch and tagging the repository as v1.3.1.
12. At the end of the assignment, marking the repository with the tag ca1-part2.

### Implementation Steps

#### Setting Up the Project

Clone the existing tutorial project into a new folder CA1 and initialize a new Git repository:

```bash
    git clone <repository-url> CA1
    cd CA1
    git init
    git add .
    git commit -m "Initial commit with tutorial project code."
```

#### Tagging the Initial Version

Create a new tag v1.1.0 and push it to the server:

```bash
    git tag v1.1.0
    git push origin v1.1.0
```

#### Adding a New Field to the Employee Entity

Add a new field "jobYears" to the Employee entity in the backend:

```java
    @NotNull
    private Integer jobYears;
```

#### Finalizing and tagging the New Feature

After implementing features and fixes, commit, push, and tag the repository accordingly:

```bash
    git add .
    git commit -m "Add jobYears field to Employee entity."
    git push origin main
    git tag v1.2.0
    git push origin v1.2.0
```

#### Bug Fixing and Additional Tags

Create a new branch to fix the invalid email issue and merge it into the master branch:

```bash
    git checkout -b fix-invalid-email
    # fix the issue
    git add .
    git commit -m "Fix invalid email issue."
    git push origin fix-invalid-email
    git checkout main
    git merge fix-invalid-email
    git push origin main
    git tag v1.3.1
    git push origin v1.3.1
```

#### Final Tagging

At the end of the assignment, mark the repository with the tag ca1-part2:

```bash
    git tag ca1-part2
    git push origin ca1-part2
```

## Associating Commits to Issues and Closing Issues via Commit Messages

### Overview

A practical feature of version control systems like Git, especially when integrated with platforms such as GitHub, is the ability to associate commits with issues directly through the commit message. This capability not only allows for better tracking of changes related to specific issues but also supports the automatic closing of issues upon the commit's integration into the mainline branch.

### How to Associate Commits with Issues

To link a commit to an issue in your project management tool (e.g., GitHub), include the issue number in your commit message prefixed with a hash (`#`). For example, if you're addressing issue number 42 in your commit, you could use:

```bash
git commit -m "Improve login functionality, addresses #42"
```

This commit message links the commit to issue 42, making it easier to track which changes pertain to which issues.

### How to Close Issues via Commit Messages

To close an issue upon the integration of a commit into the mainline branch, include the issue number in your commit message prefixed with a keyword that indicates the action to take.
For example, if you're addressing issue number 42 and want to close it upon the commit's integration, you could use:

```bash
git commit -m "Improve login functionality, closes #42"
```

This commit message not only links the commit to issue 42 but also closes the issue upon the commit's integration into the mainline branch.

By associating commits with issues and closing issues via commit messages, you can better track changes and ensure that issues are resolved as part of the development process. This practice can help streamline your development workflow and improve the overall quality of your codebase.

### Associating Commits with Issues after commit and push done

#### Introduction

In order to link certain commits to specific issues I created, I initiated the association process using the git rebase -i --root command. This allowed me to modify the assignment of some entries from 'pick' to 'reword' in the specific commits I wanted to link to the issues.

#### Process

During the interactive rebase, I identified the commits that needed to be linked to issues and changed their action from 'pick' to 'reword'. This allowed me to edit the commit messages and include references to the corresponding issues.

#### Command Used

After updating the commit messages, I executed the git push origin main --force-with-lease command to push the changes to the remote repository. This command ensures that I can force the update of the remote branch while respecting any changes made by other collaborators.

### Tutorial Style Guide

This report is designed in a tutorial style, providing a clear, step-by-step guide that enables replication of the development process and understanding the decision-making involved.

## Analysis of an Alternative Version Control Solution: Mercurial

Mercurial, like Git, is a distributed version control system (DVCS) that enables developers to track and manage changes to their codebase. However, there are key differences and similarities between the two, influencing their usage based on project needs and team preferences.

### Comparison to Git

1. **Ease of Use**: Mercurial is often praised for its simplicity and straightforward command set. New users might find Mercurial to be more approachable than Git, which has a steeper learning curve due to its more extensive set of features and commands.

2. **Branching and Merging**: Both Git and Mercurial support branching and merging, but Git's model allows for more flexibility. Git branches are lightweight and can be created, merged, and deleted with ease, which encourages experimenting with new features. Mercurial uses a slightly different approach, where branches are permanent and clones are often used for feature development.

3. **Performance**: Git generally offers better performance for large projects due to its efficient handling of branches and its compressed data format. However, Mercurial provides sufficient performance for most projects and can be simpler to use for basic operations.

4. **Tooling and Integration**: Git has a broader adoption, which means more tools and integrations are available, including popular platforms like GitHub, GitLab, and Bitbucket. Mercurial is supported by many tools as well, but the ecosystem is smaller.

### Applying Mercurial to the Assignment Goals

To achieve the same goals as presented in this assignment using Mercurial, one would follow a similar workflow with some differences in commands and concepts:

1. **Repository Initialization**: To initialize a Mercurial repository, use `hg init` instead of `git init`.

    ```bash
    hg init
    echo "# repository-name" >> README.md
    hg add README.md
    hg commit -m "first commit"
    ```

2. **Pushing Changes**: Mercurial uses `hg push` to send changes to a remote repository, similar to `git push`.

3. **Tagging Versions**: In Mercurial, tags are created with `hg tag <tagname>` and pushed with `hg push --tags`.

4. **Branching for Features and Fixes**: To create a new branch in Mercurial, use `hg branch <branchname>`. Feature development and bug fixes would follow a similar branching model to Git, with the merge process using `hg merge` and commit changes with `hg commit`.

5. **Finalizing with Tags**: Mark the end of the assignment with `hg tag ca1-part2` and push the tag as shown above.

By following these steps, one can manage version control for the CA1 assignment using Mercurial, offering an alternative to Git that may suit different project needs or personal preferences.

## Conclusion

Successfully completing the CA1 assignment demonstrated the effective use of Git to enhance a React.js and Spring Data REST application through the introduction of new features and the application of version control best practices. The exploration of Mercurial as an alternative version control solution provided valuable insights into the different tools available to developers, highlighting the importance of choosing the right tool based on project needs and team dynamics. The process underscored the critical role of version control in managing code changes, ensuring code integrity, and facilitating collaborative development efforts. Through this assignment, the practical application of Git and the theoretical consideration of Mercurial have reinforced the fundamental concepts of version control in software development practices.
